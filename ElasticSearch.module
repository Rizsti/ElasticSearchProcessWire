<?php

class ElasticSearch extends WireData implements Module, ConfigurableModule {

	/**
	 * getModuleInfo is a module required by all modules to tell ProcessWire about them
	 *
	 * @return array
	 *
	 */
	public static function getModuleInfo() {

		return array(
			'title' => 'ElasticSearch for PW', 
			'version' => 01, 
			'summary' => '...',
			'href' => 'https://github.com/jdart/ElasticSearchProcessWire',
			'singular' => true, 
			'autoload' => true, 
		);
	}

	public function init() {

		$this->pages->addHookAfter('save', $this, 'afterPageSave');
		$this->addHookAfter('Page::render', $this, 'checkForRebuildSearchData');
	}

	static public function getModuleConfigInputfields(array $data) 
	{
		$fields = new InputfieldWrapper();
		$modules = Wire::getFuel('modules');

		$field = $modules->get("InputfieldText");
		$field->name = "es_host";
		$field->label = __("ElasticSearch Host");
		$field->value = isset($data['es_host']) ? $data['es_host'] : '127.0.0.1';
		$field->description = __("An IP address will do, i.e. '127.0.0.1'.");
		$fields->add($field);

		$field = $modules->get("InputfieldText");
		$field->name = "es_port";
		$field->label = __("ElasticSearch Port");
		$field->value = isset($data['es_port']) ? $data['es_port'] : '9200';
		$field->description = __("Usually 9200.");
		$fields->add($field);
		
		$field = $modules->get('InputfieldMarkup');
        $field->label  = __('Search Data');

		$field_button = $modules->get('InputfieldButton');
		$field_button->name = 'update_all_pages';
		$field_button->value = __('Update All Pages');
		$field_button->href = 'edit?name='.wire('input')->get('name').'&es_update=all_pages';
		$field->add($field_button);

		$fields->add($field);

		return $fields;
	}

	public function afterPageSave($event) {

		$page = $event->arguments[0];

		$this->updatePageContentInElasticSearch($page);
	}

	public function checkForRebuildSearchData($event) {

		if ($this->input->get('es_update') != 'all_pages' || $event->object->template != 'admin') 
			return;

		// foreach ($this->pages as $page) {

		// 	$this->updatePageContentInElasticSearch($page);
		// }
	}

	protected function getAllContentForPage($page) {

		$all_field_data = array();

		foreach ($page->fields as $field) {

			$all_field_data[$field->name] = $page->get($field->name);
		}

		return $all_field_data;
	}

	protected function updatePageContentInElasticSearch($page) {

		$response = $this->curlJsonPut(
			$page->id, 
			$this->getAllContentForPage($page)
		);
	}

	protected function curlJsonGet($data) {
	
		static $ch;

		if (!isset($ch))
			$ch = curl_init();
		
		curl_setopt_array($ch, array(
			CURLOPT_URL => $this->getElasticSearchUrlBase().'_search',
			CURLOPT_RETURNTRANSFER => true,
			CURLOPT_POSTFIELDS => json_encode($data)
		));

		return json_decode(curl_exec($ch));
	}

	protected function curlJsonPut($id, $data) {
			
		static $ch;
		
		if (!isset($ch))
			$ch = curl_init();
		
		curl_setopt_array($ch, array(
			CURLOPT_URL => $this->getElasticSearchUrlBase().urlencode($id),
			CURLOPT_RETURNTRANSFER => true,
			CURLOPT_CUSTOMREQUEST => 'PUT',
			CURLOPT_POSTFIELDS => json_encode($data)
		));

		return json_decode(curl_exec($ch));
	}

	protected function getElasticSearchUrlBase() {

		return sprintf('http://%s:%d/%s/pw/', 
			$this->getElasticSearchHost(), 
			$this->getElasticSearchPort(),
			$this->getSiteIndex()
		);
	}

	protected function getSiteIndex() {

		return preg_replace('/[^a-z]/', '_', strtolower($this->config->httpHost));
	}

	protected function getElasticSearchHost() {

		return $this->get('es_host');
	}

	protected function getElasticSearchPort() {

		return $this->get('es_port');
	}

	public function search($query, $from=0, $size=20, $minimum_score=0.03) {

		if (is_string($query)) {

			$params = array(
				'min_score' => $minimum_score,
				'query' => array(
					'match' => array(
						'_all' => $query,
					),
				),
				'from' => $from,
				'size' => $size
			);

		} elseif (is_array($query)) {

			$params = $query;
			$params['from'] = $from;
			$params['size'] = $size;
			$params['min_score'] = $minimum_score;
		}

		$results = $this->curlJsonGet($params);

		$pages = new PageArray;

		if ( ! (int)$results->hits->total)
			return $pages;

		foreach ($results->hits->hits as $hit) 
			$pages->add($hit->_id);
		
		return $pages;
	}
}
