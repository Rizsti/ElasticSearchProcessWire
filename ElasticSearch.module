<?php

/**
 * ElasticSearch for ProcessWire
 * 
 * By Jonathan Dart
 * No Licence
 * 
 * http://metricmarketing.ca/blog/author/jonathan-dart
 *
 */

class ElasticSearch extends WireData implements Module, ConfigurableModule {

	public static function getModuleInfo() {

		return array(
			'title' => 'ElasticSearch', 
			'version' => 20, 
			'summary' => 'Make your pages searchable in ElasticSearch',
			'href' => 'https://github.com/jdart/ElasticSearchProcessWire',
			'singular' => true, 
			'autoload' => true, 
		);
	}

	public function init() {

		$this->pages->addHookAfter('save', $this, 'afterPageSave');
		$this->pages->addHookBefore('delete', $this, 'beforePageDelete');
		$this->pages->addHookBefore('trash', $this, 'beforePageTrash');
		$this->pages->addHookAfter('restored', $this, 'afterPageRestored');
		$this->addHookAfter('Page::render', $this, 'checkForRebuildSearchData');
	}

	static public function getModuleConfigInputfields(array $data) 
	{
		$fields = new InputfieldWrapper();
		$modules = Wire::getFuel('modules');

		$field = $modules->get("InputfieldText");
		$field->name = "es_host";
		$field->label = __("ElasticSearch Host");
		$field->value = isset($data['es_host']) ? $data['es_host'] : '127.0.0.1';
		$field->description = __("An IP address will do, i.e. '127.0.0.1'.");
		$fields->add($field);

		$field = $modules->get("InputfieldText");
		$field->name = "es_port";
		$field->label = __("ElasticSearch Port");
		$field->value = isset($data['es_port']) ? $data['es_port'] : '9200';
		$field->description = __("Usually 9200.");
		$fields->add($field);
		
		$field = $modules->get('InputfieldMarkup');
		$field->label  = __('Search Data');

		$field_button = $modules->get('InputfieldButton');
		$field_button->name = 'update_all_pages';
		$field_button->value = __('Index All Pages');
		$field_button->href = 'edit?name='.wire('input')->get('name').'&es_update=all_pages';
		
		$field->add($field_button);

		$fields->add($field);

		return $fields;
	}

	public function afterPageSave($event) {

		$page = $event->arguments[0];
		$this->updatePageContentInElasticSearch($page);
	}

	public function afterPageRestored($event) {

		$page = $event->arguments[0];
		$this->updatePageContentInElasticSearch($page);
	}	

	public function beforePageDelete($event) {

		$page = $event->arguments[0];
		$this->curlJsonDelete($page->id);
	}

	public function beforePageTrash($event) {

		$page = $event->arguments[0];
		$response = $this->curlJsonDelete($page->id);
	}

	public function pageShouldBeIndexed($page) {

		if ($page->isPublic())
			return true;

		return false;
	}

	public function checkForRebuildSearchData($event) {

		if ($this->input->get('es_update') != 'all_pages' || $event->object->template != 'admin') 
			return;

		foreach ($this->pages->find("id!=2, id!=7, has_parent!=2, has_parent!=7, template!=admin, include=all") as $page) {

			$this->updatePageContentInElasticSearch($page);
		}

		$this->session->message('Finished adding all pages to search index.');
	}

	protected function getAllContentForPage($page) {

		$values = array();

		foreach ($page->fields as $field) {

			$value = $page->get($field->name);
			$type = $field->type;

			if (is_null($value))
				continue;

			if ($type instanceof FieldtypeFile) 
				$value = $this->getFileTypeAsContent($value);
			elseif ($type instanceof FieldtypePage) 
				$value = $this->getPageTypeAsContent($value);
			elseif ($type instanceof FieldtypeRepeater) 
				$value = $this->getRepeaterTypeAsContent($value);
			elseif (preg_match('/Language$/', get_class($type))) {
				$value = $this->getLanguageTypeAsContent($value);
			}

			$values[$field->name] = $value;
		}

		return $values;
	}

	protected function getLanguageTypeAsContent($value)
	{
		$language_ids = wire('modules')->get('LanguageSupport')->get('otherLanguagePageIDs');
		$language_ids[] = wire('modules')->get('LanguageSupport')->get('defaultLanguagePageID');
		
		$values = array();

		foreach ($language_ids as $language_id) {
			$values[] = $value->getLanguageValue($language_id);
		}

		return $values;
	}

	protected function getFileTypeAsContent($value)	{

		$values = array();

		foreach ($value as $file) {
			$values[] = array(
				'description' => $file->description(),
				'filename' => $file->basename()
			);
		}

		return $values;
	}

	protected function getPageTypeAsContent($value)	{

		return $this->getAllContentForPage($value);
	}

	protected function getRepeaterTypeAsContent($value)	{

		$values = array();

		foreach ($value as $subPage) {
			$values[] = $this->getAllContentForPage($subPage);
		}

		return $values;
	}	

	protected function updatePageContentInElasticSearch($page) {

		if ( ! $this->pageShouldBeIndexed($page))
			return;

		$raw_array = $this->getAllContentForPage($page);

		$content = array('data' => $this->flattenArray($raw_array));

		$response = $this->curlJsonPut($page->id, $content);
	}

	protected function flattenArray($array)	{

		$return = array();

		array_walk_recursive($array, function($a) use (&$return) { 

			$return[] = $a; 
		});

		return $return;
	}

	protected function curlJsonGet($url, $data) {
	
		return $this->curlJsonRequest(null, $url, $data);
	}

	protected function curlJsonPut($id, $data) {
			
		return $this->curlJsonRequest('PUT', (int)$id, $data);
	}

	protected function curlJsonDelete($id)
	{
		return $this->curlJsonRequest('DELETE', (int)$id);
	}

	public function curlJsonRequest($method=null, $append_url='', $data=null)
	{
		static $ch;

		if ( ! isset($ch))
			$ch = curl_init();
		
		$config = array(
			CURLOPT_URL => $this->getElasticSearchUrlBase().$append_url,
			CURLOPT_RETURNTRANSFER => true,
		);

		if ( ! is_null($method))
			$config[CURLOPT_CUSTOMREQUEST] = $method;

		if ( ! is_null($data))
			$config[CURLOPT_POSTFIELDS] = json_encode($data);

		curl_setopt_array($ch, $config);

		$response = curl_exec($ch);

		if ($response === false) {
			$this->pages->error('ElasticSearch: '.curl_error($ch));
			return null;
		}

		return json_decode($response);
	}

	protected function getElasticSearchUrlBase() {

		return sprintf('http://%s:%d/%s/pw/', 
			$this->getElasticSearchHost(), 
			$this->getElasticSearchPort(),
			$this->getSiteIndex()
		);
	}

	protected function getSiteIndex() {

		return preg_replace('/[^a-z]/', '_', strtolower($this->config->httpHost));
	}

	protected function getElasticSearchHost() {

		return $this->get('es_host');
	}

	protected function getElasticSearchPort() {

		return $this->get('es_port');
	}

	public function search($query, $from=0, $size=20, $minimum_score=0.03) {

		if (is_string($query)) {

			$params = array(
				'min_score' => $minimum_score,
				'query' => array(
					'match' => array(
						'_all' => $query,
					),
				),
				'from' => $from,
				'size' => $size
			);

		} elseif (is_array($query)) {

			$params = $query;
			$params['from'] = $from;
			$params['size'] = $size;
			$params['min_score'] = $minimum_score;
		}

		$results = $this->curlJsonGet('_search', $params);

		$pages = new PageArray;

		if (isset($results->error)) {
			$this->pages->error('ElasticSearch: '.$results->error);
			return $pages;
		}

		if ( ! (int)$results->hits->total)
			return $pages;

		$pages->setTotal($results->hits->total);

		foreach ($results->hits->hits as $hit) 
			$pages->add($hit->_id);
		
		return $pages;
	}
}
